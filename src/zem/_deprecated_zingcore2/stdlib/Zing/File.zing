module Zing·File.

use Zing·Future.
use Zing·Buffer.
use Zing·Result.
use Zing·Error.
use Zing·Str.

extern res_end(i32) -> unit.
extern zi_fs_open_path(u32, i64, i32) -> i32.
extern zi_end(i32) -> unit.
extern zi_read(i32, i64, i32) -> i32.
extern zi_write(i32, i64, i32) -> i32.

;; ---------------------------------------------------------------------------
;; Layer-2 (best DX) public surface
;; ---------------------------------------------------------------------------

export type Path := Str.

export enum OpenMode [
  Read.
  WriteTruncate.
  ReadWrite.
  Append.
].

;; Strongly-typed file handle alias (represents an OS handle; kept as i32 so `<<` works).
export type Handle := i32.

export enum DirEntry [
  DirEntry(id: Buffer, name: Buffer, flags: u32).
].

fileFail trace: trace msg: msg[
  ret (Fail e: (Err kind: #FileError trace: trace msg: msg span: nil stage: #file code: trace))
].

;; ---------------------------------------------------------------------------
;; Direct file/fs syscalls (ABI v2)
;; ---------------------------------------------------------------------------

export openPathRead path: path[
  h := zi_fs_open_path(1u32, (path ptr), (path len)).
  ;; Note: until i32/u32 signedness is fully enforced in codegen, treat any
  ;; errno-style negative as an error by checking the high bit after `asU32`.
  hu := (h asU32).
  (hu >= 2147483648u32) ifTrue: [ ret (fileFail trace: #t_file_open_path msg: "file:openPathRead") ].
  (hu < 3u32) ifTrue: [ ret (fileFail trace: #t_file_open_path msg: "file:openPathRead") ].
  ret (Ok v: (hu asI32))
].

export openPathWrite path: path[
  h := zi_fs_open_path(2u32, (path ptr), (path len)).
  hu := (h asU32).
  (hu >= 2147483648u32) ifTrue: [ ret (fileFail trace: #t_file_open_path msg: "file:openPathWrite") ].
  (hu < 3u32) ifTrue: [ ret (fileFail trace: #t_file_open_path msg: "file:openPathWrite") ].
  ret (Ok v: (hu asI32))
].

export close handle: handle[
  zi_end(handle).
  ret unit
].

export openPathMode path: path mode: mode[
  ret (match mode [
    Read -> (openPathRead path: path).
    WriteTruncate -> (openPathWrite path: path).
    ReadWrite -> (fileFail trace: #t_file_open_mode_unsupported msg: "file:open ReadWrite unsupported").
    Append -> (fileFail trace: #t_file_open_mode_unsupported msg: "file:open Append unsupported").
  ])
].

export writeAll handle: handle bytes: bytes[
  n := zi_write(handle, (bytes ptr), (bytes len)).
  (n != (bytes len)) ifTrue: [ ret (fileFail trace: #t_file_write msg: "file:writeAll") ].
  ret (Ok v: unit)
].

export readInto handle: handle buf: buf cap: cap[
  n := zi_read(handle, (buf ptr), cap).
  (n < 0) ifTrue: [ ret (fileFail trace: #t_file_read msg: "file:readInto") ].
  _ := (buf sliceLen: n).
  ret (Ok v: n)
].

;; ---------------------------------------------------------------------------
;; Scoped helpers (best DX for handle-based streaming)
;; ---------------------------------------------------------------------------
;;
;; Note: if a `ret` escapes from inside `doBlock`, the close call below will not
;; run. Avoid non-local `ret` inside the block; return a Result instead.

export withOpenPathWrite path: path do: doBlock[
  (openPathWrite path: path)
    ifFail: [ :e | ret (Fail e: e) ]
    ifOk:   [ :h |
      r := (doBlock call: h).
      _ := (close handle: h).
      ret r
    ].
].

export withOpenPathRead path: path do: doBlock[
  (openPathRead path: path)
    ifFail: [ :e | ret (Fail e: e) ]
    ifOk:   [ :h |
      r := (doBlock call: h).
      _ := (close handle: h).
      ret r
    ].
].

;; Read entire file into a Buffer (fiber-blocking).
export readAllPath path: path[
  scope := Future new.
  ;; Prefer the async-cap path when available, but fall back to direct syscalls
  ;; if the host did not provide the file capability (or registration fails).
  (scope != nil) ifTrue: [
    f := (readAllPathAsync scope: scope path: path).
    (f != nil) ifTrue: [
      out := Buffer bytes: 4096.
      out clear.
      (f awaitInto: out) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | ret (Ok v: out) ].
    ].
  ].

  ;; Fall back to direct syscalls.
  (openPathRead path: path) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :h |
    out := Buffer bytes: 4096.
    out clear.
    tmp := Buffer bytes: 4096.
    tmp clear.
    done := false.
    [ done = false ] whileTrue: [
      (readInto handle: h buf: tmp cap: 4096) ifFail: [ :e | _ := (close handle: h). ret (Fail e: e) ] ifOk: [ :n |
        (n = 0) ifTrue: [
          done := true.
          unit
        ] ifFalse: [
          ;; append tmp[0..n) to out
          i := 0.
          [ i < n ] whileTrue: [
            (tmp byteAt: (i asU32)) ifFail: [ :e |
              _ := (close handle: h).
              ret (Fail e: e)
            ] ifOk: [ :b |
              (out writeByte: b) orRetAs: #t_file_read_all_append.
              unit
            ].
            i := i + 1
          ].
          unit
        ].
        unit
      ].
    ].
    _ := (close handle: h).
    ret (Ok v: out)
  ].
].

;; Write entire file from bytes (fiber-blocking).
export writeAllPath path: path bytes: bytes[
  scope := Future new.
  ;; Prefer the async-cap path when available, but fall back to direct syscalls
  ;; if the host did not provide the file capability (or registration fails).
  (scope != nil) ifTrue: [
    fw := (writeAllPathAsync scope: scope path: path bytes: bytes).
    (fw != nil) ifTrue: [
      tmp := Buffer bytes: 8.
      tmp clear.
      (fw awaitInto: tmp) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | ret (Ok v: unit) ].
    ].
  ].

  (openPathWrite path: path) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :h |
    (writeAll handle: h bytes: bytes) ifFail: [ :e | _ := (close handle: h). ret (Fail e: e) ] ifOk: [ :_ |
      _ := (close handle: h).
      ret (Ok v: unit)
    ].
  ].
].

;; List directory entries (fiber-blocking, cap-backed).
export listDir path: path[
  scope := Future new.
  (scope = nil) ifTrue: [ ret (fileFail trace: #t_file_list_spawn msg: "file:listDir scope") ].

  f := (list scope: scope fileScope: path).
  (f = nil) ifTrue: [ ret (fileFail trace: #t_file_list_spawn msg: "file:listDir spawn") ].

  payload := Buffer bytes: 4096.
  payload clear.
  (f awaitInto: payload) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ |
    (readU32le buf: payload off: 0u32) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :n |
      entries := Vec new.
      off := 4u32.
      i := 0u32.
      [ i < n ] whileTrue: [
        ;; id (HBYTES)
        (readU32le buf: payload off: off) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :idLen |
          off := off + 4u32.
          idBuf := Buffer bytes: (idLen asI32).
          idBuf clear.
          j := 0u32.
          [ j < idLen ] whileTrue: [
            (payload byteAt: (off + j)) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :b |
              (idBuf writeByte: b) orRetAs: #t_file_list_id_write.
              unit
            ].
            j := j + 1u32
          ].
          off := off + idLen.

          ;; display (HSTR)
          (readU32le buf: payload off: off) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :nameLen |
            off := off + 4u32.
            nameBuf := Buffer bytes: (nameLen asI32).
            nameBuf clear.
            k := 0u32.
            [ k < nameLen ] whileTrue: [
              (payload byteAt: (off + k)) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :b |
                (nameBuf writeByte: b) orRetAs: #t_file_list_name_write.
                unit
              ].
              k := k + 1u32
            ].
            off := off + nameLen.

            ;; flags (H4)
            (readU32le buf: payload off: off) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :flags |
              off := off + 4u32.
              _ := (entries push: (DirEntry { id: idBuf, name: nameBuf, flags: flags })).
              unit
            ].
            unit
          ].
          unit
        ].
        i := i + 1u32
      ].
      ret (Ok v: entries)
    ].
  ].
].

;; ---------------------------------------------------------------------------
;; Legacy raw handle ops (kept for compatibility with existing tests/tools)
;; ---------------------------------------------------------------------------

export writeAllRaw handle: handle bytes: bytes[
  n := zi_write(handle, (bytes ptr), (bytes len)).
  (n != (bytes len)) ifTrue: [ ret (fileFail trace: #t_file_write msg: "file:writeAllRaw") ].
  ret (Ok v: unit)
].

export readIntoRaw handle: handle buf: buf cap: cap[
  n := zi_read(handle, (buf ptr), cap).
  (n < 0) ifTrue: [ ret (fileFail trace: #t_file_read msg: "file:readIntoRaw") ].
  _ := (buf sliceLen: n).
  ret (Ok v: n)
].

export closeRaw handle: handle[
  zi_end(handle).
  ret unit
].

;; ---------------------------------------------------------------------------
;; Async DX (Future-based, uses async/default + host selectors)
;; ---------------------------------------------------------------------------

;; One-shot: write all bytes to a host path.
;; Returns a Future (or nil on failure), to be awaited with `awaitInto:`.
export writeAllPathAsync scope: scope path: path bytes: bytes[
  (scope = nil) ifTrue: [ ret nil ].
  params := Buffer bytes: (8 + (path len) + (bytes len)).
  params clear.
  (bufferWriteHbytes buf: params bytes: path) orRetAs: #t_file_async_params.
  (bufferWriteHbytes buf: params bytes: bytes) orRetAs: #t_file_async_params.
  ret (spawnBuf_capName_selector_params
    scope: scope
    capKind: "file"#utf8
    capName: "fs"#utf8
    selector: "fs.write_all_path.v1"#utf8
    paramsBuf: params
  )
].

;; One-shot: read all bytes from a host path.
;; Returns a Future (or nil on failure), to be awaited with `awaitInto:`.
export readAllPathAsync scope: scope path: path[
  (scope = nil) ifTrue: [ ret nil ].
  params := Buffer bytes: (4 + (path len)).
  params clear.
  (bufferWriteHbytes buf: params bytes: path) orRetAs: #t_file_async_params.
  ret (spawnBuf_capName_selector_params
    scope: scope
    capKind: "file"#utf8
    capName: "fs"#utf8
    selector: "fs.read_all_path.v1"#utf8
    paramsBuf: params
  )
].

readU32le buf: buf off: off[
  (buf byteAt: off) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :b0 |
    (buf byteAt: off + 1) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :b1 |
      (buf byteAt: off + 2) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :b2 |
        (buf byteAt: off + 3) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :b3 |
          v := b0 + (b1 * 256u32) + (b2 * 65536u32) + (b3 * 16777216u32).
          ret (Ok v: v)
        ]
      ]
    ]
  ].
].

;; ---------------------------------------------------------------------------
;; Futures (cap-driven cap.files.v1.1)
;; ---------------------------------------------------------------------------

;; `File list: scope fileScope:` -> Future
;; Params: HSTR scope
;; OK payload: H4 n, then repeat (HBYTES id, HSTR display, H4 flags)
export list scope: scope fileScope: fileScope[
  params := Buffer bytes: 64.
  params clear.
  ;; HSTR uses the same packed layout as HBYTES: H4 len + bytes.
  (bufferWriteHbytes buf: params bytes: fileScope) orRetAs: #t_file_list_params.
  ret (spawnBuf_capName_selector_params
    scope: scope
    capKind: "file"#utf8
    capName: "fs"#utf8
    selector: "files.list.v1"#utf8
    paramsBuf: params
  )
].

;; Convenience: list root ("").
export listRoot scope: scope[
  ret (list scope: scope fileScope: ""#utf8)
].

;; End/close a handle if the host implements it as meaningful; otherwise no-op.
export end handle: handle[
  res_end(handle).
  ret unit
].

;; `File open: scope id: ... mode: {1=READ,2=WRITE,3=READWRITE}` -> Future
export open_id_mode scope: scope id: id mode: mode[
  params := Buffer bytes: (16 + (id len)).
  params clear.
  (bufferWriteHbytes buf: params bytes: id) orRetAs: #t_file_open_params.
  (bufferWriteU32le buf: params value: mode) orRetAs: #t_file_open_params.
  ret (spawnBuf_capName_selector_params
    scope: scope
    capKind: "file"#utf8
    capName: "fs"#utf8
    selector: "files.open.v1"#utf8
    paramsBuf: params
  )
].

;; Convenience wrappers (cap.files.v1.1)
export openRead_id scope: scope id: id[
  ret (open_id_mode scope: scope id: id mode: 1u32)
].

export openWrite_id scope: scope id: id[
  ret (open_id_mode scope: scope id: id mode: 2u32)
].

export openReadWrite_id scope: scope id: id[
  ret (open_id_mode scope: scope id: id mode: 3u32)
].

;; ---------------------------------------------------------------------------
;; Payload decoding helpers
;; ---------------------------------------------------------------------------

;; files.open.v1 payload:
;;   H4 handle
;;   H4 hflags
;;   HBYTES meta
export openHandle payload: payload[
  (readU32le buf: payload off: 0u32) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :handleU |
    ret (Ok v: (handleU asI32))
  ].
].

export openHflags payload: payload[
  ret (readU32le buf: payload off: 4u32)
].

export openMetaInto payload: payload out: out[
  (readU32le buf: payload off: 8u32) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :metaLen |
    off := 12u32.
    ((payload len) < (off + (metaLen asI32))) ifTrue: [
      ret (fileFail trace: #t_file_open_meta_oob msg: "file:open meta oob")
    ].
    out clear.
    (bufferEnsureCap buf: out add: metaLen) orRetAs: #t_file_open_meta_cap.
    i := 0u32.
    [ i < metaLen ] whileTrue: [
      (payload byteAt: (off + i)) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :b |
        (out writeByte: b) orRet.
        unit
      ].
      i := i + 1u32
    ].
    ret (Ok v: unit)
  ].
].

export listCount payload: payload[
  ret (readU32le buf: payload off: 0u32)
].

export listNthDisplayInto payload: payload idx: idx out: out[
  (readU32le buf: payload off: 0u32) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :n |
    (idx >= n) ifTrue: [ ret (fileFail trace: #t_file_list_oob msg: "file:list oob") ].

    off := 4u32.
    i := 0u32.
    [ i < n ] whileTrue: [
      ;; id
      (readU32le buf: payload off: off) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :idLen |
        off := off + 4u32 + idLen.
        ;; display
        (readU32le buf: payload off: off) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :dispLen |
          off := off + 4u32.
          (dispLen > 4096u32) ifTrue: [ ret (fileFail trace: #t_file_list_bad_displen msg: "file:list displen") ].
          (i = idx) ifTrue: [
            out clear.
            (bufferEnsureCap buf: out add: dispLen) orRetAs: #t_file_list_out_cap.
            j := 0u32.
            [ j < dispLen ] whileTrue: [
              (payload byteAt: (off + j)) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :b |
                (out writeByte: b) orRet.
                unit
              ].
              j := j + 1u32
            ].
            ret (Ok v: unit)
          ].
          off := off + dispLen + 4u32. ;; skip display bytes + flags
          unit
        ].
      ].
      i := i + 1u32
    ].
    ret (fileFail trace: #t_file_list_miss msg: "file:list miss")
  ].
].

export listNthFlags payload: payload idx: idx[
  (readU32le buf: payload off: 0u32) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :n |
    (idx >= n) ifTrue: [ ret (fileFail trace: #t_file_list_oob msg: "file:list oob") ].

    off := 4u32.
    i := 0u32.
    [ i < n ] whileTrue: [
      ;; id
      (readU32le buf: payload off: off) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :idLen |
        off := off + 4u32 + idLen.
        ;; display
        (readU32le buf: payload off: off) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :dispLen |
          off := off + 4u32 + dispLen.
          (readU32le buf: payload off: off) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :flags |
            (i = idx) ifTrue: [ ret (Ok v: flags) ].
            off := off + 4u32.
            unit
          ]
        ].
      ].
      i := i + 1u32
    ].
    ret (fileFail trace: #t_file_list_miss msg: "file:list miss")
  ].
].

export listNthIdInto payload: payload idx: idx out: out[
  (readU32le buf: payload off: 0u32) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :n |
    (idx >= n) ifTrue: [ ret (fileFail trace: #t_file_list_oob msg: "file:list oob") ].

    off := 4u32.
    i := 0u32.
    [ i < n ] whileTrue: [
      (readU32le buf: payload off: off) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :idLen |
        off := off + 4u32.
        (idLen > 4096u32) ifTrue: [ ret (fileFail trace: #t_file_list_bad_idlen msg: "file:list idlen") ].
        (i = idx) ifTrue: [
          out clear.
          (bufferEnsureCap buf: out add: idLen) orRetAs: #t_file_list_out_cap.
          j := 0u32.
          [ j < idLen ] whileTrue: [
            (payload byteAt: off + j) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :b |
              (out writeByte: b) orRet.
              unit
            ].
            j := j + 1u32
          ].
          ret (Ok v: unit)
        ].
        off := off + idLen.

        ;; display
        (readU32le buf: payload off: off) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :dispLen |
          off := off + 4u32 + dispLen.
          ;; flags
          off := off + 4u32.
          unit
        ].
      ].
      i := i + 1u32
    ].
    ret (fileFail trace: #t_file_list_miss msg: "file:list miss")
  ].
].
