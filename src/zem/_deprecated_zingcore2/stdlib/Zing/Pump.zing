module Zing·Pump.

use Zing·Result.
use Zing·Error.
use Zing·Str.
use Zing·Buffer.

;; ---------------------------------------------------------------------------
;; Pump v1 surface types (PUMP.md alignment)
;; ---------------------------------------------------------------------------
;;
;; NOTE:
;; - These are enum wrappers (not structs) because enum constructors are a
;;   supported runtime value form in current codegen.
;; - The compiler recognizes `Source/Sink/Pipe` values by shape and unwraps
;;   `handle` / `stage` during `»` lowering.

export enum Source[T][
  Source(handle: i32).
].

export enum Sink[T][
  Sink(handle: i32).
].

export enum Pipe[A, B][
  Pipe(stage: u32).
  ;; User-defined bytes->bytes transducer (Stage 2 contract).
  ;;
  ;; `block` is a block id (from a block literal value).
  ;;
  ;; v1 semantics:
  ;; - The stage receives the current chunk as a `Buffer` (with `len` set to the
  ;;   bytes read).
  ;; - The stage may mutate bytes in-place (e.g. via `byteAt:` + `putByteAt:byte:`).
  ;; - The stage must not change `len`/`cap` or assume the buffer is zeroed.
  ;; - The stage block's return value is ignored (it may return `buf` for
  ;;   readability).
  ;;
  ;; v1 limitation:
  ;; - Contract is bytes->bytes via `Buffer` chunks.
  ;; - The compiler currently treats PipeDo as Pipe[Bytes,Bytes].
  PipeDo(block: i32).

  ;; User-defined line-item transducer (Bytes -> Line -> ... -> Bytes).
  ;;
  ;; Stage contract (v1):
  ;; - The pipe operates on discrete line items (Buffers containing the line's bytes).
  ;; - The line buffer is reused; handlers may mutate it in-place.
  ;; - The stage block's return value is ignored (like PipeDo).
  PipeLineDo(block: i32).

  ;; User-defined token-item transducer (Bytes -> Tokens -> ... -> Bytes).
  ;;
  ;; Stage contract (v1):
  ;; - The pipe operates on discrete token items (Buffers containing a token's bytes).
  ;; - The token buffer is reused; handlers may mutate it in-place.
  ;; - The stage block's return value is ignored (like PipeDo).
  PipeTokenDo(block: i32).
].

export enum Pipeline[T][
  ;; NOTE: `stages` is a raw pointer to a u32[] stage list (host address).
  ;; The compiler constructs this; user code should treat Pipeline as opaque.
  ;;
  ;; `kind` indicates how to interpret the stage list entries:
  ;;   0u32 = builtin u32 stage ids (zi_pump_bytes_stages3)
  ;;   1u32 = PipeDo block ids (compiler-emitted pump loop)
  ;;   2u32 = line-item pipeline (compiler-emitted pump loop)
  ;;   3u32 = token-item pipeline (compiler-emitted pump loop)
  Pipeline(src: i32, stages: i64, stageCount: u32, kind: u32).
].

;; Opaque-ish middle type used by line-oriented pipes.
;;
;; v1 representation note:
;; The runtime pipeline still operates on byte buffers; `Lines` exists to make
;; pipeline shapes explicit at compile time.
export type Lines := Bytes.

;; Line item type used by line-item pipelines (Stage 4).
;;
;; v1 representation note:
;; A Line is represented as a Buffer whose [0,len) bytes are the line payload.
;; The buffer may or may not include a trailing '\n' depending on the input.
export type Line := Buffer.

;; Opaque-ish middle type used by token-oriented pipes.
;;
;; v1 representation note:
;; Tokens are represented as Buffers (token payload bytes).
export type Tokens := Buffer.

export type SourceBytes := Source[Bytes].
export type SinkBytes   := Sink[Bytes].
export type PipeBB      := Pipe[Bytes, Bytes].
export type PipelineBytes := Pipeline[Bytes].

export sourceHandle handle: handle[
  ret (Source { handle: handle })
].

export sinkHandle handle: handle[
  ret (Sink { handle: handle })
].

export pipeStage stage: stage[
  ret (Pipe { stage: stage })
].

export pipeDo block: blk[
  ret (PipeDo { block: blk })
].

export pipeLineDo block: blk[
  ret (PipeLineDo { block: blk })
].

export pipeTokenDo block: blk[
  ret (PipeTokenDo { block: blk })
].

;; Legacy: raw stage ids (u32).
;;
;; We still accept u32 stage ids in `»` for a deprecation window, but the
;; preferred surface is `Pipe[A,B]` values (e.g. `pipeUpper` returning Pipe).
;;
;; Encoding:
;;   0u32 = #identity
;;   1u32 = #upper (ASCII)
export type PipeStage := u32.

export pipeIdentityStage[
  ret 0u32
].

export pipeUpperStage[
  ret 1u32
].

;; Built-in bytes->bytes pipes.
export pipeIdentity[ ret (Pipe { stage: 0u32 }) ].
export pipeUpper[ ret (Pipe { stage: 1u32 }) ].

;; Pipe aliases (kept for readability / older docs).
export pipeIdentityPipe[ ret (Pipe { stage: 0u32 }) ].
export pipeUpperPipe[ ret (Pipe { stage: 1u32 }) ].

;; Codec stages (Bytes↔Str) for Stage 3 pipelines.
;;
;; v1 note:
;; - Str and Bytes share the same concrete layout today (Slice[u8]).
;; - decodeUtf8 currently validates UTF-8 and does not change bytes.
;; - encodeUtf8 is currently a no-op (kept for explicitness in pipelines).
export decodeUtf8[ ret (Pipe { stage: 2u32 }) ].
export encodeUtf8[ ret (Pipe { stage: 3u32 }) ].

export decodeUtf8Pipe[ ret (Pipe { stage: 2u32 }) ].
export encodeUtf8Pipe[ ret (Pipe { stage: 3u32 }) ].

;; Stage 3: Str -> Str transforms (require decodeUtf8 earlier in pipeline).
export pipeStrUpperAscii[ ret (Pipe { stage: 4u32 }) ].

export pipeStrUpperAsciiPipe[ ret (Pipe { stage: 4u32 }) ].

;; Stage 3: Bytes <-> Lines codecs (line ending normalization).
;;
;; v1 semantics:
;; - decodeLines: CRLF -> LF (rejects bare CR and trailing CR at EOF)
;; - encodeLines: LF -> CRLF (rejects CR bytes)
export decodeLines[ ret (Pipe { stage: 5u32 }) ].
export encodeLines[ ret (Pipe { stage: 6u32 }) ].

export decodeLinesPipe[ ret (Pipe { stage: 5u32 }) ].
export encodeLinesPipe[ ret (Pipe { stage: 6u32 }) ].

;; Stage 3: Lines -> Lines transforms.
export pipeLinePrefixBar[ ret (Pipe { stage: 7u32 }) ].
export pipeLineTrimRight[ ret (Pipe { stage: 8u32 }) ].
export pipeLineNumber[ ret (Pipe { stage: 9u32 }) ].

export pipeLinePrefixBarPipe[ ret (Pipe { stage: 7u32 }) ].
export pipeLineTrimRightPipe[ ret (Pipe { stage: 8u32 }) ].
export pipeLineNumberPipe[ ret (Pipe { stage: 9u32 }) ].

;; Stage 4: Bytes <-> Line item codecs (discrete line processing).
;;
;; v1 semantics:
;; - decodeLineItems splits bytes into line Buffers.
;; - encodeLineItems joins line Buffers back into bytes.
;; - These are executed by the compiler's pump lowering (not the runtime pump).
export decodeLineItems[ ret (Pipe { stage: 12u32 }) ].
export encodeLineItems[ ret (Pipe { stage: 13u32 }) ].

export decodeLineItemsPipe[ ret (Pipe { stage: 12u32 }) ].
export encodeLineItemsPipe[ ret (Pipe { stage: 13u32 }) ].

;; Stage 4: Bytes <-> Tokens codecs (non-ladder demo).
;;
;; v1 semantics:
;; - These are no-ops at runtime; they exist to exercise compiler-level typing.
export decodeTokens[ ret (Pipe { stage: 10u32 }) ].
export encodeTokens[ ret (Pipe { stage: 11u32 }) ].

export decodeTokensPipe[ ret (Pipe { stage: 10u32 }) ].
export encodeTokensPipe[ ret (Pipe { stage: 11u32 }) ].

;; Stage-1 Pump protocol (bytes-only via handles).
;;
;; NOTE: Current implementation keys instances on the handle type (`i32`).
;; Full `Source/Sink/Pipe/Pipeline` typing will replace this as the type system
;; and protocol dispatch grow to support binary operand keys.

export protocol Pump[T] [
  pump left: T right: T trace: Symbol -> Result[unit].
].

extern zi_pump_bytes(i32, i32) -> i32.
extern zi_pump_bytes_stage(i32, i32, u32) -> i32.

export instance Pump[i32] name: #default do: [
  pump left: src right: dst trace: trace[
    rc := zi_pump_bytes(src, dst).
    (rc < 0) ifTrue: [
      ret (Fail e: (Err kind: #IOError trace: trace msg: "pump failed"))
    ].
    ret (Ok v: unit)
  ].
].

export instance Pump[i32] name: #identity do: [
  pump left: src right: dst trace: trace[
    rc := zi_pump_bytes_stage(src, dst, 0u32).
    (rc < 0) ifTrue: [
      ret (Fail e: (Err kind: #IOError trace: trace msg: "pump failed"))
    ].
    ret (Ok v: unit)
  ].
].

export instance Pump[i32] name: #upper do: [
  pump left: src right: dst trace: trace[
    rc := zi_pump_bytes_stage(src, dst, 1u32).
    (rc < 0) ifTrue: [
      ret (Fail e: (Err kind: #IOError trace: trace msg: "pump failed"))
    ].
    ret (Ok v: unit)
  ].
].
