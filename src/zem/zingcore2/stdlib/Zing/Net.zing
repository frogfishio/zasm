module Zing·Net.

use Zing·Result.
use Zing·Error.
use Zing·Buffer.
use Zing·Future.
use Zing·Async.
use Zing·Str.

netFail trace: trace msg: msg[
  ret (Fail e: (Err kind: #NetError trace: trace msg: msg span: nil stage: #net code: trace))
].

extern zi_end(i32) -> unit.
extern zi_read(i32, i64, i32) -> i32.
extern zi_write(i32, i64, i32) -> i32.

readU32le buf: buf off: off[
  (buf byteAt: off) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :b0 |
    (buf byteAt: off + 1) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :b1 |
      (buf byteAt: off + 2) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :b2 |
        (buf byteAt: off + 3) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :b3 |
          v := b0 + (b1 * 256u32) + (b2 * 65536u32) + (b3 * 16777216u32).
          ret (Ok v: v)
        ]
      ]
    ]
  ].
].

readU16le buf: buf off: off[
  (buf byteAt: off) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :b0 |
    (buf byteAt: off + 1) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :b1 |
      ret (Ok v: (b0 + (b1 * 256u32)))
    ]
  ].
].

;; Strongly-typed TCP handle alias (kept as i32 so `<<` works).
export type TcpConn := i32.

;; Strongly-typed TCP listener wrapper.
export enum TcpListener [
  TcpListener(handle: i32, port: u32).
].

listenerRaw listener: listener[
  ret (match listener [
    TcpListener { handle: h, port: _ } -> h.
  ])
].

listenerPort listener: listener[
  ret (match listener [
    TcpListener { handle: _, port: p } -> p.
  ])
].

;; Common async payload: H4 handle, H4 hflags, HBYTES meta (ignored by Net v0).
payloadHandle payload: payload[
  (payload len < 12) ifTrue: [ ret (netFail trace: #t_net_bad_payload msg: "net:payload") ].
  (readU32le buf: payload off: 0u32) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :handleU |
    ret (Ok v: (handleU asI32))
  ].
].

export close conn: conn[
  zi_end(conn).
  ret unit
].

export closeListener listener: listener[
  h := (listenerRaw listener: listener).
  zi_end(h).
  ret unit
].

export writeAll conn: conn bytes: bytes[
  n := zi_write(conn, (bytes ptr), (bytes len)).
  (n != (bytes len)) ifTrue: [ ret (netFail trace: #t_net_write msg: "net:writeAll") ].
  ret (Ok v: unit)
].

export readInto conn: conn buf: buf cap: cap[
  n := zi_read(conn, (buf ptr), cap).
  (n < 0) ifTrue: [ ret (netFail trace: #t_net_read msg: "net:readInto") ].
  _ := (buf sliceLen: n).
  ret (Ok v: n)
].

;; TCP connect via async selector `net/tcp net.tcp.connect.v1`.
;;
;; Flags:
;; - bit0 ALLOW_DNS (stage1: denied)
;; - bit1 PREFER_IPV6
;; - bit2 NODELAY
export tcpConnect host: host port: port flags: flags[
  scope := Future new.
  (scope = nil) ifTrue: [ ret (netFail trace: #t_net_no_async msg: "net:async_missing") ].

  params := Buffer bytes: 256.
  params clear.
  (bufferWriteHbytes buf: params bytes: host) orRetAs: #t_net_params.
  (bufferWriteU16le buf: params value: port) orRetAs: #t_net_params.
  (bufferWriteU32le buf: params value: flags) orRetAs: #t_net_params.

  f := (spawnBuf_capName_selector_params
    scope: scope
    capKind: "net"#utf8
    capName: "tcp"#utf8
    selector: "net.tcp.connect.v1"#utf8
    paramsBuf: params
  ).
  (f = nil) ifTrue: [ ret (netFail trace: #t_net_spawn msg: "net:spawn") ].

  out := Buffer bytes: 128.
  (f awaitInto: out)
    ifFail: [ :_ | ret (netFail trace: #t_net_connect msg: "net:connect") ]
    ifOk:   [ :_ | unit ].

  (payloadHandle payload: out) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :h |
    ret (Ok v: h)
  ].
].

;; Listen on loopback and return the listener fd + bound port.
;; Params: H2 port + H4 flags
export tcpListen port: port flags: flags[
  scope := Future new.
  (scope = nil) ifTrue: [ ret (netFail trace: #t_net_no_async msg: "net:async_missing") ].

  params := Buffer bytes: 16.
  params clear.
  (bufferWriteU16le buf: params value: port) orRetAs: #t_net_params.
  (bufferWriteU32le buf: params value: flags) orRetAs: #t_net_params.

  f := (spawnBuf_capName_selector_params
    scope: scope
    capKind: "net"#utf8
    capName: "tcp"#utf8
    selector: "net.tcp.listen.v1"#utf8
    paramsBuf: params
  ).
  (f = nil) ifTrue: [ ret (netFail trace: #t_net_spawn msg: "net:spawn") ].

  out := Buffer bytes: 128.
  (f awaitInto: out)
    ifFail: [ :_ | ret (netFail trace: #t_net_listen msg: "net:listen") ]
    ifOk:   [ :_ | unit ].

  (out len < 14) ifTrue: [ ret (netFail trace: #t_net_bad_payload msg: "net:payload") ].
  (readU32le buf: out off: 0) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :h |
    (readU16le buf: out off: 12) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :p |
      ret (Ok v: (TcpListener { handle: (h asI32), port: p }))
    ]
  ].
].

;; Accept a connection on a listener (fiber-blocking).
export tcpAccept listener: listener[
  scope := Future new.
  (scope = nil) ifTrue: [ ret (netFail trace: #t_net_no_async msg: "net:async_missing") ].

  lfd := (listenerRaw listener: listener).
  params := Buffer bytes: 8.
  params clear.
  (bufferWriteU32le buf: params value: (lfd asU32)) orRetAs: #t_net_params.

  f := (spawnBuf_capName_selector_params
    scope: scope
    capKind: "net"#utf8
    capName: "tcp"#utf8
    selector: "net.tcp.accept.v1"#utf8
    paramsBuf: params
  ).
  (f = nil) ifTrue: [ ret (netFail trace: #t_net_spawn msg: "net:spawn") ].

  out := Buffer bytes: 128.
  (f awaitInto: out)
    ifFail: [ :_ | ret (netFail trace: #t_net_accept msg: "net:accept") ]
    ifOk:   [ :_ | unit ].

  (payloadHandle payload: out) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :h |
    ret (Ok v: h)
  ].
].

;; ---------------------------------------------------------------------------
;; Scoped helpers (best DX for conn-based streaming)
;; ---------------------------------------------------------------------------
;;
;; Note: if a `ret` escapes from inside `doBlock`, the close call below will not
;; run. Avoid non-local `ret` inside the block; return a Result instead.

export withTcpConnect host: host port: port flags: flags do: doBlock[
  (tcpConnect host: host port: port flags: flags)
    ifFail: [ :e | ret (Fail e: e) ]
    ifOk:   [ :c |
      r := (doBlock call: c).
      close conn: c.
      ret r
    ].
].
