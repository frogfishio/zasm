module Zing·Future.

use Zing·Async.
use Zing·Buffer.
use Zing·Result.
use Zing·Error.
use Zing·Str.

;; Futures (stdlib v0)
;;
;; NOTE: Prefer `...Into` APIs for payloads that would otherwise allocate and
;; move buffers around. (Result payload slots are pointer-width; use them
;; sparingly for performance, not because they are unsafe.)
;;
;; Timeout semantics (IMPORTANT):
;; - Any parameter named `timeoutMs` is an overall deadline for the entire
;;   operation (register/await/cancel/join/all).
;; - `timeoutMs = 0u32` means unbounded (wait forever).
;; - Internally, the library computes a remaining timeout and passes it to the
;;   host blocking waits so timeouts are not “reset per frame”.

extern zi_future_scope_new(i32, u32, u32) -> u32.
extern zi_future_scope_handle(u32) -> i32.
extern zi_future_scope_lo(u32) -> u32.
extern zi_future_scope_hi(u32) -> u32.
extern zi_future_scope_next_req(u32) -> u32.
extern zi_future_scope_next_future(u32) -> u32.
extern zi_future_scope_free(u32) -> i32.

extern zi_future_new(u32, u32, u32) -> u32.
extern zi_future_scope(u32) -> u32.
extern zi_future_handle(u32) -> i32.
extern zi_future_id_lo(u32) -> u32.
extern zi_future_id_hi(u32) -> u32.

futureFail trace: trace msg: msg[
  ret (Fail e: (Err kind: #FutureError trace: trace msg: msg span: nil stage: #async code: trace))
].

;; ---------------------------------------------------------------------------
;; "Sexy" DX layer (message-based API)
;; ---------------------------------------------------------------------------

;; Create a default async scope.
;; Returns nil on failure (because Result[Scope] is not safe yet).
export new[
  (open open: "dev"#utf8) ifFail: [ :e |
    _ := e.
    ret nil
  ] ifOk: [ :scope |
    ret scope
  ].
].

;; `Scope open: "dev"#utf8` -> Result[u32]
;; (Scope is a runtime-managed id; the handle + ids live in zingcore.)
export open open: sessionId[
  (asyncCtlOpenDefault sessionId: sessionId) ifFail: [ :e |
    ret (Fail e: e)
  ] ifOk: [ :handle |
    scope := zi_future_scope_new(handle, 1u32, 0u32).
    ret (Ok v: scope)
  ].
].

;; Escape hatch for debugging / low-level integration.
export scopeHandle scope[
  ret (zi_future_scope_handle(scope))
].

;; Release the runtime-managed scope slot (and its Hopper arena).
;;
;; This is intentionally minimal for now: it frees the scope-owned arena and
;; drops the scope record from the runtime. Future work may also close the
;; underlying async handle deterministically.
export closeScope scope[
  (scope = nil) ifTrue: [ ret (Ok v: unit) ].
  rc := zi_future_scope_free(scope).
  (rc < 0) ifTrue: [ ret (futureFail trace: #t_scope_close msg: "scope:close") ].
  ret (Ok v: unit)
].

;; `scope spawn: capKind capName: ... selector: ... params: ...`
;; Returns nil on failure.
export spawn_capName_selector_params scope capKind capName selector params[
  (scope = nil) ifTrue: [ ret nil ].

  reqLo := zi_future_scope_next_req(scope).
  reqHi := 0u32.
  futureLo := zi_future_scope_next_future(scope).
  futureHi := 0u32.

  (futureRegisterCap
    handle: (zi_future_scope_handle(scope))
    reqLo: reqLo reqHi: reqHi
    scopeLo: (zi_future_scope_lo(scope)) scopeHi: (zi_future_scope_hi(scope))
    taskLo: 0u32 taskHi: 0u32
    futureLo: futureLo futureHi: futureHi
    capKind: capKind
    capName: capName
    selector: selector
    params: params
  ) ifFail: [ :e |
    _ := e.
    ret nil
  ] ifOk: [ :_ |
    ret (zi_future_new(scope, futureLo, futureHi))
  ].
].

;; `scope spawn: ... paramsBuf: buf` (Buffer params, returns nil on failure).
export spawnBuf_capName_selector_params scope capKind capName selector paramsBuf[
  (scope = nil) ifTrue: [ ret nil ].

  reqLo := zi_future_scope_next_req(scope).
  reqHi := 0u32.
  futureLo := zi_future_scope_next_future(scope).
  futureHi := 0u32.

  (futureRegisterCapBuf
    handle: (zi_future_scope_handle(scope))
    reqLo: reqLo reqHi: reqHi
    scopeLo: (zi_future_scope_lo(scope)) scopeHi: (zi_future_scope_hi(scope))
    taskLo: 0u32 taskHi: 0u32
    futureLo: futureLo futureHi: futureHi
    capKind: capKind
    capName: capName
    selector: selector
    paramsBuf: paramsBuf
  ) ifFail: [ :e |
    _ := e.
    ret nil
  ] ifOk: [ :_ |
    ret (zi_future_new(scope, futureLo, futureHi))
  ].
].

;; `scope joinBounded: fuelLo` (fuelHi defaults to 0).
export joinBounded scope fuelLo[
  reqLo := zi_future_scope_next_req(scope).
  reqHi := 0u32.
  (scopeJoinBounded
    handle: (zi_future_scope_handle(scope))
    reqLo: reqLo reqHi: reqHi
    scopeLo: (zi_future_scope_lo(scope)) scopeHi: (zi_future_scope_hi(scope))
    fuelLo: fuelLo fuelHi: 0u32
  )
].

;; `future awaitInto: out` -> Result[unit]
export awaitInto future out[
  futureLo := zi_future_id_lo(future).
  futureHi := zi_future_id_hi(future).
  ret (futureAwaitInto
    handle: (zi_future_handle(future))
    futureLo: futureLo
    futureHi: futureHi
    out: out
  )
].

;; `future await` -> Result[Buffer]
export await future[
  out := Buffer bytes: 4096.
  (awaitInto(future, out)) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | ret (Ok v: out) ].
].

;; `future awaitIntoTimeout: out timeoutMs: t` -> Result[unit]
export awaitIntoTimeout_timeoutMs future out timeoutMs[
  futureLo := zi_future_id_lo(future).
  futureHi := zi_future_id_hi(future).
  ret (futureAwaitIntoTimeout
    handle: (zi_future_handle(future))
    futureLo: futureLo
    futureHi: futureHi
    out: out
    timeoutMs: timeoutMs
  )
].

;; `future awaitTimeout: t` -> Result[Buffer]
export awaitTimeout_timeoutMs future timeoutMs[
  out := Buffer bytes: 4096.
  (awaitIntoTimeout_timeoutMs(future, out, timeoutMs)) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | ret (Ok v: out) ].
].

;; `futureAll2AwaitInto a: outA: b: outB:` -> Result[unit]
export futureAll2AwaitInto a: a outA: outA b: b outB: outB[
  ret (futureAll2AwaitIntoTimeout
    a: a outA: outA
    b: b outB: outB
    timeoutMs: 0u32
  )
].

;; `futureAll2AwaitIntoTimeout a: outA: b: outB: timeoutMs:` -> Result[unit]
export futureAll2AwaitIntoTimeout a: a outA: outA b: b outB: outB timeoutMs: timeoutMs[
  scopeA := zi_future_scope(a).
  scopeB := zi_future_scope(b).
  (scopeA != scopeB) ifTrue: [
    ret (futureFail trace: #t_future_all_scope_mismatch msg: "future:scope_mismatch")
  ].

  ;; Join waits host-side (no busy-spin); timeoutMs is an overall deadline.
  start := 0u32.
  (timeoutMs != 0u32) ifTrue: [ start := asyncNowMs ].

  remainJoin := timeoutMs.
  (timeoutMs != 0u32) ifTrue: [
    now := asyncNowMs.
    elapsed := now - start.
    (elapsed >= timeoutMs) ifTrue: [ ret (futureFail trace: #t_future_join_timeout msg: "future:join_timeout") ].
    remainJoin := timeoutMs - elapsed
  ].
  reqLo := zi_future_scope_next_req(scopeA).
  reqHi := 0u32.
  (scopeJoinBoundedTimeout
    handle: (zi_future_scope_handle(scopeA))
    reqLo: reqLo reqHi: reqHi
    scopeLo: (zi_future_scope_lo(scopeA)) scopeHi: (zi_future_scope_hi(scopeA))
    fuelLo: 4294967295u32 fuelHi: 0u32
    timeoutMs: remainJoin
  ) ifFail: [ :e |
    ((e trace) = #t_future_join_limit) ifTrue: [
      ret (futureFail trace: #t_future_join_timeout msg: "future:join_timeout")
    ].
    ret (Fail e: e)
  ] ifOk: [ :_ | unit ].

  remainAwait := timeoutMs.
  (timeoutMs != 0u32) ifTrue: [
    now := asyncNowMs.
    elapsed := now - start.
    (elapsed >= timeoutMs) ifTrue: [ ret (futureFail trace: #t_future_timeout msg: "future:timeout") ].
    remainAwait := timeoutMs - elapsed
  ].

  (awaitIntoTimeout_timeoutMs(a, outA, remainAwait)) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | unit ].
  (awaitIntoTimeout_timeoutMs(b, outB, remainAwait)) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | unit ].
  ret (Ok v: unit)
].

;; `futureAll3AwaitIntoTimeout a: outA: b: outB: c: outC: timeoutMs:` -> Result[unit]
export futureAll3AwaitIntoTimeout a: a outA: outA b: b outB: outB c: c outC: outC timeoutMs: timeoutMs[
  scopeA := zi_future_scope(a).
  scopeB := zi_future_scope(b).
  scopeC := zi_future_scope(c).
  (scopeA != scopeB) ifTrue: [
    ret (futureFail trace: #t_future_all_scope_mismatch msg: "future:scope_mismatch")
  ].
  (scopeA != scopeC) ifTrue: [
    ret (futureFail trace: #t_future_all_scope_mismatch msg: "future:scope_mismatch")
  ].

  start := 0u32.
  (timeoutMs != 0u32) ifTrue: [ start := asyncNowMs ].

  remainJoin := timeoutMs.
  (timeoutMs != 0u32) ifTrue: [
    now := asyncNowMs.
    elapsed := now - start.
    (elapsed >= timeoutMs) ifTrue: [ ret (futureFail trace: #t_future_join_timeout msg: "future:join_timeout") ].
    remainJoin := timeoutMs - elapsed
  ].

  reqLo := zi_future_scope_next_req(scopeA).
  reqHi := 0u32.
  (scopeJoinBoundedTimeout
    handle: (zi_future_scope_handle(scopeA))
    reqLo: reqLo reqHi: reqHi
    scopeLo: (zi_future_scope_lo(scopeA)) scopeHi: (zi_future_scope_hi(scopeA))
    fuelLo: 4294967295u32 fuelHi: 0u32
    timeoutMs: remainJoin
  ) ifFail: [ :e |
    ((e trace) = #t_future_join_limit) ifTrue: [
      ret (futureFail trace: #t_future_join_timeout msg: "future:join_timeout")
    ].
    ret (Fail e: e)
  ] ifOk: [ :_ | unit ].

  remainAwait := timeoutMs.
  (timeoutMs != 0u32) ifTrue: [
    now := asyncNowMs.
    elapsed := now - start.
    (elapsed >= timeoutMs) ifTrue: [ ret (futureFail trace: #t_future_timeout msg: "future:timeout") ].
    remainAwait := timeoutMs - elapsed
  ].

  (awaitIntoTimeout_timeoutMs(a, outA, remainAwait)) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | unit ].
  (awaitIntoTimeout_timeoutMs(b, outB, remainAwait)) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | unit ].
  (awaitIntoTimeout_timeoutMs(c, outC, remainAwait)) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | unit ].
  ret (Ok v: unit)
].

;; `futureAll3AwaitInto a: outA: b: outB: c: outC:` -> Result[unit]
export futureAll3AwaitInto a: a outA: outA b: b outB: outB c: c outC: outC[
  ret (futureAll3AwaitIntoTimeout
    a: a outA: outA
    b: b outB: outB
    c: c outC: outC
    timeoutMs: 0u32
  )
].

;; ---------------------------------------------------------------------------
;; Receiver-style DX (compiler-lowered)
;; ---------------------------------------------------------------------------

;; `Future all: a b: b` is a compile-time-only surface form used by the
;; compiler to lower:
;;   (Future all: a b: b) awaitInto: outA outB: outB
;; into a direct call to `futureAll2AwaitIntoTimeout ... timeoutMs: 0u32`.
export all_b a b[
  _ := a.
  _ := b.
  ret (nil)
].

;; `Future all: a b: b c: c` compile-time-only stub (lowered by compiler).
export all_b_c a b c[
  _ := a.
  _ := b.
  _ := c.
  ret (nil)
].

;; `future cancel` -> Result[unit]
export cancel future[
  scope := zi_future_scope(future).
  reqLo := zi_future_scope_next_req(scope).
  reqHi := 0u32.
  futureLo := zi_future_id_lo(future).
  futureHi := zi_future_id_hi(future).
  ret (futureCancel
    handle: (zi_future_handle(future))
    reqLo: reqLo reqHi: reqHi
    futureLo: futureLo
    futureHi: futureHi
  )
].

export futureRegisterCap handle: handle reqLo: reqLo reqHi: reqHi scopeLo: scopeLo scopeHi: scopeHi taskLo: taskLo taskHi: taskHi futureLo: futureLo futureHi: futureHi capKind: capKind capName: capName selector: selector params: params[
  ret (futureRegisterCapTimeout
    handle: handle reqLo: reqLo reqHi: reqHi
    scopeLo: scopeLo scopeHi: scopeHi
    taskLo: taskLo taskHi: taskHi
    futureLo: futureLo futureHi: futureHi
    capKind: capKind capName: capName selector: selector params: params
    timeoutMs: 0u32
  )
].

export futureRegisterCapBuf handle: handle reqLo: reqLo reqHi: reqHi scopeLo: scopeLo scopeHi: scopeHi taskLo: taskLo taskHi: taskHi futureLo: futureLo futureHi: futureHi capKind: capKind capName: capName selector: selector paramsBuf: paramsBuf[
  ret (futureRegisterCapBufTimeout
    handle: handle reqLo: reqLo reqHi: reqHi
    scopeLo: scopeLo scopeHi: scopeHi
    taskLo: taskLo taskHi: taskHi
    futureLo: futureLo futureHi: futureHi
    capKind: capKind capName: capName selector: selector paramsBuf: paramsBuf
    timeoutMs: 0u32
  )
].

export futureRegisterCapTimeout handle: handle reqLo: reqLo reqHi: reqHi scopeLo: scopeLo scopeHi: scopeHi taskLo: taskLo taskHi: taskHi futureLo: futureLo futureHi: futureHi capKind: capKind capName: capName selector: selector params: params timeoutMs: timeoutMs[
  src := Buffer bytes: 4096.
  (asyncSourceCapInto out: src capKind: capKind capName: capName selector: selector params: params) orRetAs: #t_future_source.

  frame := Buffer bytes: 4096.
  (asyncZaxEncodeFrameInto out: frame
    kind: 1u32 op: 1u32 timeoutMs: 0u32
    reqLo: reqLo reqHi: reqHi
    scopeLo: scopeLo scopeHi: scopeHi
    taskLo: taskLo taskHi: taskHi
    futureLo: futureLo futureHi: futureHi
    payload: src
  ) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | unit ].

  (asyncZaxWriteFrame handle: handle frame: frame) orRetAs: #t_future_write.

  ack := Buffer bytes: 4096.
  start := 0u32.
  (timeoutMs != 0u32) ifTrue: [ start := asyncNowMs ].
  [ true ] whileTrue: [
    remain := timeoutMs.
    (timeoutMs != 0u32) ifTrue: [
      now := asyncNowMs.
      elapsed := now - start.
      (elapsed >= timeoutMs) ifTrue: [ ret (futureFail trace: #t_future_ack_timeout msg: "future:ack_timeout") ].
      remain := timeoutMs - elapsed
    ].
    (timeoutMs != 0u32) ifTrue: [
      (remain = 0u32) ifTrue: [
        ret (futureFail trace: #t_future_ack_timeout msg: "future:ack_timeout")
      ].
    ].

    ;; Read raw from the handle while waiting for the ACK, and push back any
    ;; unrelated frames so other waiters (await/join) can still observe them.
    (asyncZaxReadFrameRawIntoTimeout handle: handle out: ack timeoutMs: remain) ifFail: [ :e |
      ((e trace) = #t_async_timeout) ifTrue: [
        ret (futureFail trace: #t_future_ack_timeout msg: "future:ack_timeout")
      ].
      ret (Fail e: e)
    ] ifOk: [ :_ |
      (asyncZaxFrameOp frame: ack) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :op |
        (asyncZaxFrameReqLo frame: ack) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :rlo |
          (asyncZaxFrameReqHi frame: ack) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :rhi |
            matches := (rlo = reqLo).
            matches ifTrue: [ matches := (rhi = reqHi). ].
            matches ifTrue: [
              (op = 101u32) ifTrue: [ ret (Ok v: unit) ].
              (op = 102u32) ifTrue: [ ret (futureFail trace: #t_future_register_fail msg: "future:register_fail") ].
              ret (futureFail trace: #t_future_bad_ack msg: "future:bad_ack")
            ].
            (asyncZaxPushFrame handle: handle frame: ack) orRetAs: #t_future_read.
            unit
          ]
        ]
      ].
      unit
    ].
    unit
  ].
  ret (futureFail trace: #t_future_ack_loop msg: "future:ack_loop")
].

export futureRegisterCapBufTimeout handle: handle reqLo: reqLo reqHi: reqHi scopeLo: scopeLo scopeHi: scopeHi taskLo: taskLo taskHi: taskHi futureLo: futureLo futureHi: futureHi capKind: capKind capName: capName selector: selector paramsBuf: paramsBuf timeoutMs: timeoutMs[
  src := Buffer bytes: 4096.
  (asyncSourceCapBufInto out: src capKind: capKind capName: capName selector: selector paramsBuf: paramsBuf) orRetAs: #t_future_source.

  frame := Buffer bytes: 4096.
  (asyncZaxEncodeFrameInto out: frame
    kind: 1u32 op: 1u32 timeoutMs: 0u32
    reqLo: reqLo reqHi: reqHi
    scopeLo: scopeLo scopeHi: scopeHi
    taskLo: taskLo taskHi: taskHi
    futureLo: futureLo futureHi: futureHi
    payload: src
  ) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | unit ].

  (asyncZaxWriteFrame handle: handle frame: frame) orRetAs: #t_future_write.

  ack := Buffer bytes: 4096.
  start := 0u32.
  (timeoutMs != 0u32) ifTrue: [ start := asyncNowMs ].
  [ true ] whileTrue: [
    remain := timeoutMs.
    (timeoutMs != 0u32) ifTrue: [
      now := asyncNowMs.
      elapsed := now - start.
      (elapsed >= timeoutMs) ifTrue: [ ret (futureFail trace: #t_future_ack_timeout msg: "future:ack_timeout") ].
      remain := timeoutMs - elapsed
    ].
    (timeoutMs != 0u32) ifTrue: [
      (remain = 0u32) ifTrue: [
        ret (futureFail trace: #t_future_ack_timeout msg: "future:ack_timeout")
      ].
    ].

    (asyncZaxReadFrameRawIntoTimeout handle: handle out: ack timeoutMs: remain) ifFail: [ :e |
      ((e trace) = #t_async_timeout) ifTrue: [
        ret (futureFail trace: #t_future_ack_timeout msg: "future:ack_timeout")
      ].
      ret (Fail e: e)
    ] ifOk: [ :_ |
      (asyncZaxFrameOp frame: ack) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :op |
        (asyncZaxFrameReqLo frame: ack) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :rlo |
          (asyncZaxFrameReqHi frame: ack) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :rhi |
            matches := (rlo = reqLo).
            matches ifTrue: [ matches := (rhi = reqHi). ].
            matches ifTrue: [
              (op = 101u32) ifTrue: [ ret (Ok v: unit) ].
              (op = 102u32) ifTrue: [ ret (futureFail trace: #t_future_register_fail msg: "future:register_fail") ].
              ret (futureFail trace: #t_future_bad_ack msg: "future:bad_ack")
            ].
            (asyncZaxPushFrame handle: handle frame: ack) orRetAs: #t_future_read.
            unit
          ]
        ]
      ].
      unit
    ].
    unit
  ].
  ret (futureFail trace: #t_future_ack_loop msg: "future:ack_loop")
].

export futureAwaitInto handle: handle futureLo: futureLo futureHi: futureHi out: out[
  ret (futureAwaitIntoTimeout handle: handle futureLo: futureLo futureHi: futureHi out: out timeoutMs: 0u32)
].

export futureAwaitIntoTimeout handle: handle futureLo: futureLo futureHi: futureHi out: out timeoutMs: timeoutMs[
  frame := Buffer bytes: 4096.
  start := 0u32.
  (timeoutMs != 0u32) ifTrue: [ start := asyncNowMs ].
  [ true ] whileTrue: [
    ;; First, try to pop a queued frame matching this future id.
    (asyncZaxPopMatchFutureInto handle: handle out: frame futureLo: futureLo futureHi: futureHi) orRetAs: #t_future_read.
    ((frame len) > 0) ifTrue: [
      (asyncZaxFrameOp frame: frame) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :op |
        (op = 110u32) ifTrue: [ ret (asyncZaxFutureOkValueInto frame: frame out: out) ].
        (op = 111u32) ifTrue: [ ret (futureFail trace: #t_future_fail msg: "future:fail") ].
        (op = 112u32) ifTrue: [ ret (futureFail trace: #t_future_cancel msg: "future:cancelled") ].
        unit
      ].
      unit
    ].

    ;; Otherwise, read raw from the handle and push back frames for other futures.
    remain := timeoutMs.
    (timeoutMs != 0u32) ifTrue: [
      now := asyncNowMs.
      elapsed := now - start.
      (elapsed >= timeoutMs) ifTrue: [ ret (futureFail trace: #t_future_event_timeout msg: "future:event_timeout") ].
      remain := timeoutMs - elapsed
    ].
    (timeoutMs != 0u32) ifTrue: [
      (remain = 0u32) ifTrue: [
        ret (futureFail trace: #t_future_event_timeout msg: "future:event_timeout")
      ].
    ].
    (asyncZaxReadFrameRawIntoTimeout handle: handle out: frame timeoutMs: remain) ifFail: [ :e |
      ((e trace) = #t_async_timeout) ifTrue: [
        ret (futureFail trace: #t_future_event_timeout msg: "future:event_timeout")
      ].
      ret (Fail e: e)
    ] ifOk: [ :_ |
      (asyncZaxFrameOp frame: frame) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :op |
        (asyncZaxFrameFutureLo frame: frame) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :flo |
          (asyncZaxFrameFutureHi frame: frame) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :fhi |
            matches := (flo = futureLo).
            matches ifTrue: [ matches := (fhi = futureHi). ].
            matches ifTrue: [
              (op = 110u32) ifTrue: [ ret (asyncZaxFutureOkValueInto frame: frame out: out) ].
              (op = 111u32) ifTrue: [ ret (futureFail trace: #t_future_fail msg: "future:fail") ].
              (op = 112u32) ifTrue: [ ret (futureFail trace: #t_future_cancel msg: "future:cancelled") ].
              unit
            ] ifFalse: [
              (asyncZaxPushFrame handle: handle frame: frame) orRetAs: #t_future_read.
              unit
            ].
            unit
          ]
        ]
      ].
      unit
    ].
    unit
  ].
  ret (futureFail trace: #t_future_event_loop msg: "future:event_loop")
].

export futureCancel handle: handle reqLo: reqLo reqHi: reqHi futureLo: futureLo futureHi: futureHi[
  ret (futureCancelTimeout handle: handle reqLo: reqLo reqHi: reqHi futureLo: futureLo futureHi: futureHi timeoutMs: 0u32)
].

export futureCancelTimeout handle: handle reqLo: reqLo reqHi: reqHi futureLo: futureLo futureHi: futureHi timeoutMs: timeoutMs[
  frame := Buffer bytes: 4096.
  empty := Buffer bytes: 0.
  (asyncZaxEncodeFrameInto out: frame
    kind: 1u32 op: 2u32 timeoutMs: 0u32
    reqLo: reqLo reqHi: reqHi
    scopeLo: 0u32 scopeHi: 0u32
    taskLo: 0u32 taskHi: 0u32
    futureLo: futureLo futureHi: futureHi
    payload: empty
  ) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | unit ].
  (asyncZaxWriteFrame handle: handle frame: frame) orRetAs: #t_future_cancel_write.

  ack := Buffer bytes: 4096.
  start := 0u32.
  (timeoutMs != 0u32) ifTrue: [ start := asyncNowMs ].
  [ true ] whileTrue: [
    remain := timeoutMs.
    (timeoutMs != 0u32) ifTrue: [
      now := asyncNowMs.
      elapsed := now - start.
      (elapsed >= timeoutMs) ifTrue: [ ret (futureFail trace: #t_future_cancel_timeout msg: "future:cancel_timeout") ].
      remain := timeoutMs - elapsed
    ].
    (timeoutMs != 0u32) ifTrue: [
      (remain = 0u32) ifTrue: [
        ret (futureFail trace: #t_future_cancel_timeout msg: "future:cancel_timeout")
      ].
    ].
    (asyncZaxReadFrameRawIntoTimeout handle: handle out: ack timeoutMs: remain) ifFail: [ :e |
      ((e trace) = #t_async_timeout) ifTrue: [
        ret (futureFail trace: #t_future_cancel_timeout msg: "future:cancel_timeout")
      ].
      ret (Fail e: e)
    ] ifOk: [ :_ |
      (asyncZaxFrameOp frame: ack) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :op |
        (asyncZaxFrameReqLo frame: ack) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :rlo |
          (asyncZaxFrameReqHi frame: ack) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :rhi |
            matches := (rlo = reqLo).
            matches ifTrue: [ matches := (rhi = reqHi). ].
            matches ifTrue: [
              (op = 101u32) ifTrue: [ ret (Ok v: unit) ].
              (op = 102u32) ifTrue: [ ret (futureFail trace: #t_future_cancel_fail msg: "future:cancel_fail") ].
              unit
            ].
            (asyncZaxPushFrame handle: handle frame: ack) orRetAs: #t_future_cancel_read.
            unit
          ]
        ]
      ].
      unit
    ].
    unit
  ].
  ret (futureFail trace: #t_future_cancel_loop msg: "future:cancel_loop")
].

export scopeJoinBounded handle: handle reqLo: reqLo reqHi: reqHi scopeLo: scopeLo scopeHi: scopeHi fuelLo: fuelLo fuelHi: fuelHi[
  ret (scopeJoinBoundedTimeout
    handle: handle reqLo: reqLo reqHi: reqHi
    scopeLo: scopeLo scopeHi: scopeHi
    fuelLo: fuelLo fuelHi: fuelHi
    timeoutMs: 0u32
  )
].

export scopeJoinBoundedTimeout handle: handle reqLo: reqLo reqHi: reqHi scopeLo: scopeLo scopeHi: scopeHi fuelLo: fuelLo fuelHi: fuelHi timeoutMs: timeoutMs[
  tmo := timeoutMs.
  (tmo > 65535u32) ifTrue: [ tmo := 65535u32 ].

  payload := Buffer bytes: 8.
  payload clear.
  (bufferWriteU32le buf: payload value: fuelLo) orRetAs: #t_future_join_write.
  (bufferWriteU32le buf: payload value: fuelHi) orRetAs: #t_future_join_write.

  frame := Buffer bytes: 4096.
  (asyncZaxEncodeFrameInto out: frame
    kind: 1u32 op: 4u32 timeoutMs: tmo
    reqLo: reqLo reqHi: reqHi
    scopeLo: scopeLo scopeHi: scopeHi
    taskLo: 0u32 taskHi: 0u32
    futureLo: 0u32 futureHi: 0u32
    payload: payload
  ) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | unit ].

  (asyncZaxWriteFrame handle: handle frame: frame) orRetAs: #t_future_join_send.

  resp := Buffer bytes: 4096.
  start := 0u32.
  (timeoutMs != 0u32) ifTrue: [ start := asyncNowMs ].
  [ true ] whileTrue: [
    remain := timeoutMs.
    (timeoutMs != 0u32) ifTrue: [
      now := asyncNowMs.
      elapsed := now - start.
      (elapsed >= timeoutMs) ifTrue: [ ret (futureFail trace: #t_future_join_timeout msg: "future:join_timeout") ].
      remain := timeoutMs - elapsed
    ].
    (timeoutMs != 0u32) ifTrue: [
      (remain = 0u32) ifTrue: [
        ret (futureFail trace: #t_future_join_timeout msg: "future:join_timeout")
      ].
    ].
    ;; Read raw from the handle while waiting for the join response, and push
    ;; back any unrelated frames so other waiters (await) can still observe them.
    (asyncZaxReadFrameRawIntoTimeout handle: handle out: resp timeoutMs: remain) ifFail: [ :e |
      ((e trace) = #t_async_timeout) ifTrue: [
        ret (futureFail trace: #t_future_join_timeout msg: "future:join_timeout")
      ].
      ret (Fail e: e)
    ] ifOk: [ :_ |
      (asyncZaxFrameOp frame: resp) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :op |
        (asyncZaxFrameReqLo frame: resp) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :rlo |
          (asyncZaxFrameReqHi frame: resp) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :rhi |
            matches := (rlo = reqLo).
            matches ifTrue: [ matches := (rhi = reqHi). ].
            matches ifTrue: [
              (op = 120u32) ifTrue: [ ret (Ok v: unit) ].
              (op = 121u32) ifTrue: [ ret (futureFail trace: #t_future_join_limit msg: "future:join_limit") ].
              (op = 102u32) ifTrue: [ ret (futureFail trace: #t_future_join_fail msg: "future:join_fail") ].
              unit
            ].
            (asyncZaxPushFrame handle: handle frame: resp) orRetAs: #t_future_join_read.
            unit
          ]
        ]
      ].
      unit
    ].
    unit
  ].
  ret (futureFail trace: #t_future_join_loop msg: "future:join_loop")
].
