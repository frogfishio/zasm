module Zing·Async.

use Zing·Buffer.
use Zing·Result.
use Zing·Error.
use Zing·Str.

;; ABI v2: capability open via syscalls.
extern zi_cap_open(i64) -> i32.
extern zi_handle_hflags(i32) -> u32.

;; Runtime queue for pushback of ZAX frames (per handle).
;; Used by higher-level protocols to avoid dropping unrelated frames while
;; synchronously waiting for specific ACK/response frames.
extern zi_zax_q_push(i32, u64, i32) -> i32.
extern zi_zax_q_pop(i32, u64, i32) -> i32.
extern zi_zax_q_pop_match(i32, u64, i32, u32) -> i32.

;; Time helpers for sane waiting/backoff.
extern zi_time_now_ms_u32() -> u32.
extern zi_time_sleep_ms(u32) -> i32.

;; Host-driven blocking helpers (reduce guest busy-loops).
extern zi_read_exact_timeout(i32, i64, i32, u32) -> i32.
extern zi_zax_read_frame_timeout(i32, i64, i32, u32) -> i32.

;; core/async.zing — async plumbing (v2)
;;
;; The host boundary is syscall-style (`zi_*`). We still speak the async data
;; plane over a returned handle; opening that handle is done via `zi_cap_open`.

asyncFail trace: trace msg: msg[
  ret (Fail e: (Err kind: #AsyncError trace: trace msg: msg span: nil stage: #async code: trace))
].

asyncReadU16le buf: buf off: off[
  (buf byteAt: off) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :b0 |
    (buf byteAt: (off + 1)) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :b1 |
      ret (Ok v: (b0 + (b1 * 256u32)))
    ]
  ].
].

asyncReadU32le buf: buf off: off[
  (buf byteAt: off) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :b0 |
    (buf byteAt: (off + 1)) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :b1 |
      (buf byteAt: (off + 2)) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :b2 |
        (buf byteAt: (off + 3)) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :b3 |
          v := b0 + (b1 * 256u32) + (b2 * 65536u32) + (b3 * 16777216u32).
          ret (Ok v: v)
        ]
      ]
    ]
  ].
].

export asyncNowMs[
  ret zi_time_now_ms_u32
].

export asyncSleepMs ms: ms[
  _ := zi_time_sleep_ms(ms).
  ret unit
].

export asyncYield[
  _ := zi_time_sleep_ms(0u32).
  ret unit
].

export asyncBufWriteBytes buf: buf bytes: bytes[
  i := 0.
  n := bytes len.
  [ i < n ] whileTrue: [
    b := (bytes at: i).
    (buf writeByte: b) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | unit ].
    i := i + 1
  ].
  ret (Ok v: unit)
].

;; Build a cap-source payload (variant=2) into `out`.
;; Shape matches zingcore/caps/async/cap_async_simple.c handle_register_future.
export asyncSourceCapInto out: out capKind: capKind capName: capName selector: selector params: params[
  kindLen := capKind len.
  nameLen := capName len.
  selLen := selector len.
  paramsLen := params len.
  bodyLen := 4 + kindLen + 4 + nameLen + 4 + selLen + 4 + paramsLen.
  total := 1 + 4 + bodyLen.
  out clear.
  (bufferEnsureCap buf: out add: total) orRetAs: #t_async_source_cap.
  (out writeByte: 2u32) orRet.
  (bufferWriteU32le buf: out value: (bodyLen + 0u32)) orRet.
  (bufferWriteU32le buf: out value: (kindLen + 0u32)) orRet.
  (asyncBufWriteBytes buf: out bytes: capKind) orRetAs: #t_async_source_cap_write.
  (bufferWriteU32le buf: out value: (nameLen + 0u32)) orRet.
  (asyncBufWriteBytes buf: out bytes: capName) orRetAs: #t_async_source_cap_write.
  (bufferWriteU32le buf: out value: (selLen + 0u32)) orRet.
  (asyncBufWriteBytes buf: out bytes: selector) orRetAs: #t_async_source_cap_write.
  (bufferWriteU32le buf: out value: (paramsLen + 0u32)) orRet.
  (asyncBufWriteBytes buf: out bytes: params) orRetAs: #t_async_source_cap_write.
  ret (Ok v: unit)
].

;; Same as asyncSourceCapInto, but accepts params as a Buffer (avoids requiring `at:`).
export asyncSourceCapBufInto out: out capKind: capKind capName: capName selector: selector paramsBuf: paramsBuf[
  kindLen := capKind len.
  nameLen := capName len.
  selLen := selector len.
  paramsLen := paramsBuf len.
  bodyLen := 4 + kindLen + 4 + nameLen + 4 + selLen + 4 + paramsLen.
  total := 1 + 4 + bodyLen.
  out clear.
  (bufferEnsureCap buf: out add: total) orRetAs: #t_async_source_cap.
  (out writeByte: 2u32) orRet.
  (bufferWriteU32le buf: out value: (bodyLen + 0u32)) orRet.
  (bufferWriteU32le buf: out value: (kindLen + 0u32)) orRet.
  (asyncBufWriteBytes buf: out bytes: capKind) orRetAs: #t_async_source_cap_write.
  (bufferWriteU32le buf: out value: (nameLen + 0u32)) orRet.
  (asyncBufWriteBytes buf: out bytes: capName) orRetAs: #t_async_source_cap_write.
  (bufferWriteU32le buf: out value: (selLen + 0u32)) orRet.
  (asyncBufWriteBytes buf: out bytes: selector) orRetAs: #t_async_source_cap_write.
  (bufferWriteU32le buf: out value: (paramsLen + 0u32)) orRet.
  (asyncBufWriteBuf buf: out src: paramsBuf) orRetAs: #t_async_source_cap_write.
  ret (Ok v: unit)
].

;; Open an async cap handle by (kind,name) with a session id and flags.
;; This is the common entrypoint used by higher-level libraries (Future, File, Exec).
export asyncCapOpen kind: kind name: name sessionId: sessionId flags: flags[
  ;; params := HBYTES sessionId + H4 flags
  params := Buffer bytes: (8 + (sessionId len)).
  params clear.
  (bufferWriteHbytes buf: params bytes: sessionId) orRetAs: #t_async_params.
  (bufferWriteU32le buf: params value: flags) orRetAs: #t_async_params.

  ;; Request layout (little-endian):
  ;;   u64 kind_ptr, u32 kind_len,
  ;;   u64 name_ptr, u32 name_len,
  ;;   u32 mode,
  ;;   u64 params_ptr, u32 params_len
  req := Buffer bytes: 40.
  req clear.

  (bufferWriteU64le buf: req value: ((kind ptr) + 0u64)) orRetAs: #t_async_req.
  (bufferWriteU32le buf: req value: ((kind len) + 0u32)) orRetAs: #t_async_req.
  (bufferWriteU64le buf: req value: ((name ptr) + 0u64)) orRetAs: #t_async_req.
  (bufferWriteU32le buf: req value: ((name len) + 0u32)) orRetAs: #t_async_req.
  (bufferWriteU32le buf: req value: 1u32) orRetAs: #t_async_req. ;; mode=1
  (bufferWriteU64le buf: req value: ((params ptr) + 0u64)) orRetAs: #t_async_req.
  (bufferWriteU32le buf: req value: ((params len) + 0u32)) orRetAs: #t_async_req.

  h := zi_cap_open((req ptr)).
  (h < 3) ifTrue: [ ret (asyncFail trace: #t_async_open msg: "async:open") ].
  _ := zi_handle_hflags(h).
  ret (Ok v: h)
].

export asyncCtlOpenDefault sessionId: sessionId flags: flags[
  ret (asyncCapOpen
    kind: "async"#utf8
    name: "default"#utf8
    sessionId: sessionId
    flags: flags
  )
].

export asyncCtlOpenDefault sessionId: sessionId[
  ret (asyncCtlOpenDefault sessionId: sessionId flags: 0u32)
].

;; ---------------------------------------------------------------------------
;; ZAX1 data-plane framing (minimal, v0)
;; ---------------------------------------------------------------------------

asyncBufWriteBuf buf: buf src: src[
  i := 0.
  n := (src len).
  [ i < n ] whileTrue: [
    (src byteAt: i) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :b |
      (buf writeByte: b) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | unit ].
      unit
    ].
    i := i + 1
  ].
  ret (Ok v: unit)
].

export asyncReadExactIntoTimeout handle: handle buf: buf len: want timeoutMs: timeoutMs[
  buf clear.
  (want < 0) ifTrue: [ ret (asyncFail trace: #t_async_payload msg: "async:payload") ].
  (bufferEnsureCap buf: buf add: want) orRetAs: #t_async_payload.
  n := zi_read_exact_timeout(handle, (buf ptr), want, timeoutMs).
  (n < 0) ifTrue: [ ret (asyncFail trace: #t_async_read msg: "async:read") ].
  (n = 0) ifTrue: [ ret (asyncFail trace: #t_async_timeout msg: "async:timeout") ].
  _ := (buf sliceLen: n).
  ret (Ok v: unit)
].

;; Read exactly `want` bytes and append them to `buf` (does not clear `buf`).
export asyncReadExactAppendTimeout handle: handle buf: buf len: want timeoutMs: timeoutMs[
  (want < 0) ifTrue: [ ret (asyncFail trace: #t_async_payload msg: "async:payload") ].
  base := (buf len).
  (bufferEnsureCap buf: buf add: want) orRetAs: #t_async_payload.
  off := ((base asU32) + 0u64).
  n := zi_read_exact_timeout(handle, ((buf ptr) + off), want, timeoutMs).
  (n < 0) ifTrue: [ ret (asyncFail trace: #t_async_read msg: "async:read") ].
  (n = 0) ifTrue: [ ret (asyncFail trace: #t_async_timeout msg: "async:timeout") ].
  _ := (buf sliceLen: (base + n)).
  ret (Ok v: unit)
].

export asyncReadExactInto handle: handle buf: buf len: want[
  ret (asyncReadExactIntoTimeout handle: handle buf: buf len: want timeoutMs: 0u32)
].

export asyncZaxEncodeFrameInto out: out kind: kind op: op timeoutMs: timeoutMs reqLo: reqLo reqHi: reqHi scopeLo: scopeLo scopeHi: scopeHi taskLo: taskLo taskHi: taskHi futureLo: futureLo futureHi: futureHi payload: payload[
  plen := payload len.
  total := 48 + plen.
  out clear.
  (bufferEnsureCap buf: out add: total) orRetAs: #t_async_zax_write.
  ;; Write magic as raw bytes (avoid relying on literal layout for indexing).
  (out writeByte: 90u32) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | unit ].  ;; 'Z'
  (out writeByte: 65u32) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | unit ].  ;; 'A'
  (out writeByte: 88u32) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | unit ].  ;; 'X'
  (out writeByte: 49u32) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | unit ].  ;; '1'
  (bufferWriteU16le buf: out value: 1u32) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | unit ].
  (bufferWriteU16le buf: out value: kind) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | unit ].
  (bufferWriteU16le buf: out value: op) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | unit ].
  (bufferWriteU16le buf: out value: timeoutMs) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | unit ].
  (bufferWriteU32le buf: out value: reqLo) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | unit ].
  (bufferWriteU32le buf: out value: reqHi) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | unit ].
  (bufferWriteU32le buf: out value: scopeLo) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | unit ].
  (bufferWriteU32le buf: out value: scopeHi) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | unit ].
  (bufferWriteU32le buf: out value: taskLo) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | unit ].
  (bufferWriteU32le buf: out value: taskHi) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | unit ].
  (bufferWriteU32le buf: out value: futureLo) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | unit ].
  (bufferWriteU32le buf: out value: futureHi) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | unit ].
  (bufferWriteU32le buf: out value: (plen + 0u32)) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | unit ].
  (asyncBufWriteBuf buf: out src: payload) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | unit ].
  ret (Ok v: unit)
].

export asyncZaxWriteFrame handle: handle frame: frame[
  n := (handle writeBytes: frame).
  (n < 0) ifTrue: [
    ret (asyncFail trace: #t_async_write msg: "async:write")
  ].
  (n != (frame len)) ifTrue: [
    ret (asyncFail trace: #t_async_short_write msg: "async:short_write")
  ].
  ret (Ok v: unit)
].

export asyncZaxPushFrame handle: handle frame: frame[
  r := zi_zax_q_push(handle, (frame ptr), (frame len)).
  (r < 0) ifTrue: [ ret (asyncFail trace: #t_async_zax_push msg: "zax:push") ].
  ret (Ok v: unit)
].

;; Raw frame read from the underlying handle (does not consult the pushback queue).
export asyncZaxReadFrameRawInto handle: handle out: out maxPayload: maxPayload[
  ret (asyncZaxReadFrameRawIntoTimeout handle: handle out: out maxPayload: maxPayload timeoutMs: 0u32)
].

export asyncZaxReadFrameRawInto handle: handle out: out[
  ret (asyncZaxReadFrameRawInto handle: handle out: out maxPayload: (1024u32 * 1024u32))
].

;; Raw frame read with a bounded timeout (ms). If timeoutMs=0, this behaves like
;; asyncZaxReadFrameRawInto (unbounded).
export asyncZaxReadFrameRawIntoTimeout handle: handle out: out maxPayload: maxPayload timeoutMs: timeoutMs[
  out clear.
  n := zi_zax_read_frame_timeout(handle, (out ptr), (out cap), timeoutMs).
  (n < 0) ifTrue: [ ret (asyncFail trace: #t_async_bad_frame msg: "async:bad_frame") ].
  (n = 0) ifTrue: [ ret (asyncFail trace: #t_async_timeout msg: "async:timeout") ].
  _ := (out sliceLen: n).
  (asyncReadU32le buf: out off: 44) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :plen |
    (maxPayload != 0u32) ifTrue: [
      (plen > maxPayload) ifTrue: [ ret (asyncFail trace: #t_async_payload msg: "async:payload") ]
    ].
    ret (Ok v: unit)
  ].
].

export asyncZaxReadFrameRawIntoTimeout handle: handle out: out timeoutMs: timeoutMs[
  ret (asyncZaxReadFrameRawIntoTimeout handle: handle out: out maxPayload: (1024u32 * 1024u32) timeoutMs: timeoutMs)
].

;; Frame read with pushback support:
;; - First tries to pop a queued frame for this handle.
;; - If none queued, reads from the underlying handle.
export asyncZaxReadFrameInto handle: handle out: out maxPayload: maxPayload[
  out clear.
  n := zi_zax_q_pop(handle, (out ptr), (out cap)).
  (n < 0) ifTrue: [ ret (asyncFail trace: #t_async_zax_pop msg: "zax:pop") ].
  (n > 0) ifTrue: [
    _ := (out sliceLen: n).
    ret (Ok v: unit)
  ].
  ret (asyncZaxReadFrameRawInto handle: handle out: out maxPayload: maxPayload)
].

export asyncZaxReadFrameInto handle: handle out: out[
  ret (asyncZaxReadFrameInto handle: handle out: out maxPayload: (1024u32 * 1024u32))
].

;; Frame read with pushback + bounded timeout (ms). If timeoutMs=0, behaves like
;; asyncZaxReadFrameInto (unbounded).
export asyncZaxReadFrameIntoTimeout handle: handle out: out maxPayload: maxPayload timeoutMs: timeoutMs[
  out clear.
  n := zi_zax_q_pop(handle, (out ptr), (out cap)).
  (n < 0) ifTrue: [ ret (asyncFail trace: #t_async_zax_pop msg: "zax:pop") ].
  (n > 0) ifTrue: [
    _ := (out sliceLen: n).
    ret (Ok v: unit)
  ].
  ret (asyncZaxReadFrameRawIntoTimeout handle: handle out: out maxPayload: maxPayload timeoutMs: timeoutMs)
].

export asyncZaxReadFrameIntoTimeout handle: handle out: out timeoutMs: timeoutMs[
  ret (asyncZaxReadFrameIntoTimeout handle: handle out: out maxPayload: (1024u32 * 1024u32) timeoutMs: timeoutMs)
].

;; Pop a queued frame for `handle` that matches the provided future id.
;; Returns Ok(unit) with `out` filled on match; Ok(unit) with empty `out` if none queued.
export asyncZaxPopMatchFutureInto handle: handle out: out futureLo: futureLo futureHi: futureHi[
  out clear.
  (futureHi != 0u32) ifTrue: [ ret (asyncFail trace: #t_async_zax_future_hi msg: "zax:future_hi") ].
  n := zi_zax_q_pop_match(handle, (out ptr), (out cap), futureLo).
  (n < 0) ifTrue: [ ret (asyncFail trace: #t_async_zax_pop msg: "zax:pop") ].
  (n = 0) ifTrue: [ ret (Ok v: unit) ].
  _ := (out sliceLen: n).
  ret (Ok v: unit)
].

export asyncZaxFrameOp frame: frame[
  (asyncReadU16le buf: frame off: 8) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :op | ret (Ok v: op) ].
].

export asyncZaxFrameReqLo frame: frame[
  ret (asyncReadU32le buf: frame off: 12)
].

export asyncZaxFrameReqHi frame: frame[
  ret (asyncReadU32le buf: frame off: 16)
].

export asyncZaxFrameFutureLo frame: frame[
  ret (asyncReadU32le buf: frame off: 36)
].

export asyncZaxFrameFutureHi frame: frame[
  ret (asyncReadU32le buf: frame off: 40)
].

export asyncZaxFutureOkValueInto frame: frame out: out[
  out clear.
  flen := frame len.
  (flen < 52) ifTrue: [ ret (asyncFail trace: #t_async_bad_frame msg: "zax:short") ].
  (asyncReadU32le buf: frame off: 44) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :plen |
    payloadStart := 48.
    (payloadStart + (plen asI32) > flen) ifTrue: [ ret (asyncFail trace: #t_async_bad_frame msg: "zax:len") ].
    (plen < 4u32) ifTrue: [ ret (asyncFail trace: #t_async_bad_frame msg: "zax:val") ].
    (asyncReadU32le buf: frame off: payloadStart) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :n |
      valLen := (n asI32).
      (4 + valLen > (plen asI32)) ifTrue: [ ret (asyncFail trace: #t_async_bad_frame msg: "zax:val") ].
      (bufferEnsureCap buf: out add: valLen) orRetAs: #t_async_payload.
      i := 0.
      [ i < valLen ] whileTrue: [
        (frame byteAt: (payloadStart + 4 + i)) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :b |
          (out writeByte: b) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | unit ].
          unit
        ].
        i := i + 1
      ].
      ret (Ok v: unit)
    ]
  ].
].

;; Extract the fail `code` (Bytes/Str) from a ZAX fail frame payload.
;; Payload shape (from host): H4 code_len, H4 msg_len, code bytes, msg bytes.
export asyncZaxFailCodeInto frame: frame out: out[
  out clear.
  flen := frame len.
  (flen < 56) ifTrue: [ ret (asyncFail trace: #t_async_bad_frame msg: "zax:short") ].
  (asyncReadU32le buf: frame off: 44) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :plen |
    payloadStart := 48.
    (payloadStart + (plen asI32) > flen) ifTrue: [ ret (asyncFail trace: #t_async_bad_frame msg: "zax:len") ].
    (plen < 8u32) ifTrue: [ ret (asyncFail trace: #t_async_bad_frame msg: "zax:fail") ].
    (asyncReadU32le buf: frame off: payloadStart) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :codeLenU |
      (asyncReadU32le buf: frame off: payloadStart + 4) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :msgLenU |
        codeLen := (codeLenU asI32).
        msgLen := (msgLenU asI32).
        (8 + codeLen + msgLen > (plen asI32)) ifTrue: [ ret (asyncFail trace: #t_async_bad_frame msg: "zax:fail") ].
        (bufferEnsureCap buf: out add: codeLen) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | unit ].
        i := 0.
        [ i < codeLen ] whileTrue: [
          (frame byteAt: (payloadStart + 8 + i)) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :b |
            (out writeByte: b) ifFail: [ :e | ret (Fail e: e) ] ifOk: [ :_ | unit ].
            unit
          ].
          i := i + 1
        ].
        ret (Ok v: unit)
      ]
    ]
  ].
].
