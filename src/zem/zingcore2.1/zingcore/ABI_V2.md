# Zingcore ABI v2.0 (syscall-style, `zi_*`)

Status: DRAFT (intended to become normative)

This ABI is the contract between:
- the **guest** (code generated by the Zing compiler + stdlib), and
- the **host runtime** (native library, WASM embedder, or JIT host).

The entire boundary is a small set of **C ABI functions** named `zi_*`.
There is **no `_ctl`**, and no byte-framed selector protocols in v2.

---

## 0. Core model

### 0.1 Guest memory model

All pointers passed to `zi_*` are **guest pointers**:
- In WASM: offsets into linear memory.
- In native/JIT: guest pointer values are currently passed as **native addresses** (64-bit on 64-bit targets).

The host MUST bounds-check `(ptr,len)` arguments against the guest memory range.

### 0.2 Handles

Most resources are accessed through a 32-bit handle:

- Type: `zi_handle_t` (signed `int32_t`)
- Invalid: `-1`
- Reserved:
  - `0` = stdin-like read handle (optional)
  - `1` = stdout-like write handle (optional)
  - `2` = stderr/telemetry-like write handle (optional)

### 0.3 Results and errors

All `zi_*` functions return either:
- a non-negative integer (count/value), or
- a `zi_err_t` negative error code.

No function may crash the host on invalid input; it must return an error.

---

## 1. Versioning

### 1.1 ABI version

```c
uint32_t zi_abi_version(void);
```

This must return `0x00020000` for ABI v2.0.

### 1.2 Feature flags (optional)

```c
uint64_t zi_abi_features(void);
```

Bitset of optional features implemented (e.g. FS, ASYNC, TIME).

Current v2 feature bits (non-normative; see `zingcore/include/zi_abi_v2.h`):
- `ZI_FEAT_FS`
- `ZI_FEAT_ASYNC`
- `ZI_FEAT_TIME`
- `ZI_FEAT_EXEC`
- `ZI_FEAT_PROC`

---

## 2. Memory

Zing wants a single allocation surface usable in all targets.

```c
int32_t zi_alloc(int32_t size);
int32_t zi_free(int32_t ptr);
```

Rules:
- `zi_alloc(size)` returns guest pointer (>=0) or negative error.
- `zi_free(ptr)` returns `ZI_OK` or negative error.
- Allocator behavior must be deterministic given a deterministic run configuration.

Notes:
- Runtimes may implement this as arena allocation; `zi_free` may be a no-op.

---

## 3. Raw I/O (byte streams)

These are the minimal building blocks for sinks/pumps.

```c
int32_t zi_read(zi_handle_t h, int32_t dst_ptr, int32_t cap);
int32_t zi_write(zi_handle_t h, int32_t src_ptr, int32_t len);
int32_t zi_end(zi_handle_t h);
```

Semantics:
- `zi_read` returns `0..cap` bytes read, `0` = EOF, negative = error.
- `zi_write` returns `0..len` bytes written, negative = error.
- `zi_end` is idempotent; returns `ZI_OK` or error.

Determinism:
- Chunking (`zi_read` segmentation) must be deterministic under deterministic mode.

### 3.2 Proc (argv/env)

Command-line args and environment are exposed via copy-out syscalls so the
guest never receives host pointers directly.

```c
int32_t zi_argc(void);
int32_t zi_argv_len(uint32_t index);
int32_t zi_argv_copy(uint32_t index, uint64_t out_ptr, int32_t out_cap);

int32_t zi_env_get_len(uint64_t key_ptr, int32_t key_len);
int32_t zi_env_get_copy(uint64_t key_ptr, int32_t key_len,
                        uint64_t out_ptr, int32_t out_cap);
```

Rules:
- `zi_argc()` returns `>=0`.
- `zi_argv_len(i)` returns `>=0` byte length or negative error (`ZI_E_NOENT` if out of range).
- `zi_argv_copy(i, out_ptr, out_cap)` copies `argv[i]` bytes (no NUL) and returns bytes written.
- `zi_env_get_len(key_ptr, key_len)` returns value length or `ZI_E_NOENT` if missing.
- `zi_env_get_copy(...)` copies value bytes (no NUL) and returns bytes written.

### 3.1 Blocking helpers (host-driven waits)

To keep guest code small and avoid busy-spin loops in the stdlib, the debug/native
runtime provides two helpers that “block” by advancing the deterministic clock
(`zi_time_sleep_ms`) while waiting for data:

```c
// Read exactly `want` bytes into `dst_ptr`.
// Returns want on success, 0 on timeout, <0 on error.
int32_t zi_read_exact_timeout(zi_handle_t h, int64_t dst_ptr, int32_t want, uint32_t timeout_ms);

// Read one full ZAX1 frame into `out_ptr` (>=48 bytes).
// Returns total frame bytes written (>0), 0 on timeout, <0 on error.
int32_t zi_zax_read_frame_timeout(zi_handle_t h, int64_t out_ptr, int32_t out_cap, uint32_t timeout_ms);
```

Notes:
- These are currently implemented for the native/debug runtime pack and are used by `stdlib/Zing/Async.zing`.
- The portable/WASM story will likely encode pointers as `int32_t` offsets once the guest memory model is finalized.

---

## 4. Hopper arenas (scope-owned) (draft)

Zing’s direction is that complex allocations (Buffers, Vectors, Maps, etc.)
should be hosted in a safe arena owned by the runtime. The first step is a tiny
scope-owned bump allocator associated with async scopes.

Draft ABI:

```c
// Allocate `size` bytes with `align` (power-of-two). Returns 0 on failure.
int64_t  zi_hop_alloc(uint32_t scope_id, uint32_t size, uint32_t align);

// Get current cursor (mark), and release/reset.
uint32_t zi_hop_mark(uint32_t scope_id);
int32_t  zi_hop_release(uint32_t scope_id, uint32_t mark, uint32_t wipe);
int32_t  zi_hop_reset(uint32_t scope_id, uint32_t wipe);

// Introspection.
uint32_t zi_hop_used(uint32_t scope_id);
uint32_t zi_hop_cap(uint32_t scope_id);

// Free a scope and release its arena.
int32_t  zi_future_scope_free(uint32_t scope_id);
```

Notes:
- `wipe` is best-effort zeroing for debugging/safety.
- In native debug builds, pointers are currently native addresses (`int64_t`).
- The WASM/JIT story will evolve toward linear-memory offsets.

## 5. Telemetry

Telemetry is best-effort; it must not block indefinitely.

```c
int32_t zi_telemetry(int32_t topic_ptr, int32_t topic_len,
                     int32_t msg_ptr, int32_t msg_len);
```

---

## 6. Capability discovery/open (typed, not framed)

Capabilities are the mechanism for optional host services (FS, NET, TIME, …).
Discovery and opening are **typed calls**, not a general message protocol.

### 5.1 Capability identity

A capability is identified by two UTF-8 strings:
- `kind` (e.g. `"file"`, `"net"`, `"time"`, `"async"`)
- `name` (e.g. `"fs"`, `"tcp"`, `"default"`)

### 5.2 Listing capabilities

Returning pointers to host-owned strings is not portable to WASM/JIT, so list
APIs are **copy-out** into guest memory.

```c
int32_t zi_cap_count(void);
int32_t zi_cap_get_size(int32_t index);
int32_t zi_cap_get(int32_t index, int32_t out_ptr, int32_t out_cap);
```

`zi_cap_get` output format (packed bytes written into `out_ptr`):

```
H4 kind_len
bytes[kind_len] kind
H4 name_len
bytes[name_len] name
H4 flags
```

Rules:
- `zi_cap_count()` returns `n>=0` or error.
- `zi_cap_get_size(i)` returns required bytes for `zi_cap_get` or error.
- `zi_cap_get(i, out_ptr, out_cap)` returns bytes written or error.
- Listing order MUST be stable and deterministic (lexicographic by `(kind,name)`).

`flags` bits (v2):
- bit0 `ZI_CAP_CAN_OPEN`
- bit1 `ZI_CAP_PURE` (deterministic given inputs)
- bit2 `ZI_CAP_MAY_BLOCK`

### 5.3 Opening capabilities

`zi_cap_open` is a syscall that takes a pointer to a guest-resident request
struct, to keep the call arity small and portable.

```c
typedef struct {
  int32_t kind_ptr;
  int32_t kind_len;
  int32_t name_ptr;
  int32_t name_len;
  uint32_t mode;
  int32_t params_ptr;
  int32_t params_len;
} zi_cap_open_req_v2;

zi_handle_t zi_cap_open(int32_t req_ptr);
uint32_t    zi_handle_hflags(zi_handle_t h);
```

Rules:
- On success, `zi_cap_open(req_ptr)` returns a handle (`>=3`).
- On failure, returns a negative error code.
- `zi_handle_hflags(h)` returns `hflags` for an open handle, or `0` if unknown.

`hflags` bits (v2):
- bit0 `ZI_H_READABLE`
- bit1 `ZI_H_WRITABLE`
- bit2 `ZI_H_ENDABLE`
- bit3 `ZI_H_SEEKABLE` (reserved)

---

## 7. File system capability (`kind="file", name="fs"`)

This section defines a concrete cap interface with no message framing.

All paths are UTF-8; all ids are opaque bytes.

### 6.1 Listing entries

Copy-out API (portable):

```c
int32_t zi_fs_count(void);
int32_t zi_fs_get_size(int32_t index);
int32_t zi_fs_get(int32_t index, int32_t out_ptr, int32_t out_cap);
```

`zi_fs_get` output format:

```
H4 id_len
bytes[id_len] id
H4 name_len
bytes[name_len] name
H4 flags
```

Rules:
- Ordering MUST be stable and deterministic.

### 6.2 Opening files

Open by id or open by path. `mode` selects semantics.

`mode` (v2):
- 1 = read
- 2 = write (create or truncate is runtime-defined; prefer “create if missing”)
- 3 = readwrite

```c
zi_handle_t zi_fs_open_id(uint32_t mode, int32_t id_ptr, int32_t id_len);
zi_handle_t zi_fs_open_path(uint32_t mode, int32_t path_ptr, int32_t path_len);
```

Returns a handle (>=3) which is then used with `zi_read/zi_write/zi_end`.

---

## 8. Async capability (`kind="async", name="default"`)

Async is optional. When present, it provides a handle suitable for evented waits.

```c
// Opened via zi_cap_open("async","default",...)
```

The exact async event model (poll, wait, wake, futures) is intentionally not
locked in by the ABI core yet. The rule is: if a feature needs async, it should
be expressed as typed syscalls (not a framed selector protocol).

---

## 9. Time capability (`kind="time", name="default"`)

Time is a capability because it is a determinism footgun.

```c
int32_t zi_time_now_ms_u32(void);     // returns u32 in low bits (non-negative)
int32_t zi_time_sleep_ms(uint32_t ms);
```

Determinism:
- In deterministic mode, the host MUST provide a deterministic clock source.
- In nondeterministic mode, the host may use wall clock.

Implementation note (this repo):
- `zi_time_*` is deterministic and **does not consult wall clock**.
- The clock starts at `0` and advances only via `zi_time_sleep_ms`.
---

## 10. Error codes

---

## 11. Exec capability (`kind="exec", name="default"`) (draft)

First-release policy can be “exec anything”, i.e. defer to the host OS security model.

```c
int32_t zi_exec_run(int32_t cmd_ptr, int32_t cmd_len);
```

Rules:
- `cmd` is UTF-8 text.
- Returns `0..255` process exit status on success, negative error on failure.
- Recommended implementation for POSIX hosts: `/bin/sh -c <cmd>`.

All error codes are negative `int32_t`.

```c
enum {
  ZI_OK = 0,

  ZI_E_INVALID = -1,      // bad argument, out of range, null when not allowed
  ZI_E_BOUNDS  = -2,      // guest ptr/len out of bounds
  ZI_E_NOENT   = -3,      // not found (cap missing, file missing)
  ZI_E_DENIED  = -4,      // permission denied / policy
  ZI_E_CLOSED  = -5,      // handle closed / ended
  ZI_E_AGAIN   = -6,      // would block / try again
  ZI_E_NOSYS   = -7,      // not implemented by this runtime
  ZI_E_OOM     = -8,      // allocation failure
  ZI_E_IO      = -9,      // generic I/O failure
  ZI_E_INTERNAL = -10,    // host bug (should be rare; still must not crash)
};
```

---

## 12. Conformance expectations (fast runner)

At minimum, a conforming runtime should pass:
- ABI version returns `0x00020000`
- `zi_cap_count/zi_cap_get` stable ordering and bounds checks
- `zi_cap_open` returns `ZI_E_NOENT` for missing caps
- handle rules: reserved 0/1/2, dynamic handles >=3, `zi_end` idempotent
- pointer bounds errors return `ZI_E_BOUNDS` (not crash)
